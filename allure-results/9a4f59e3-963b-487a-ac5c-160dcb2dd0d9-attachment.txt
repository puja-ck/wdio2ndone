{
  "script": "return (function setup(done) {\n    var NAMESPACE = '__webdriverajax';\n    var PKG_PREFIX = '[wdio-intercept-service]: ';\n\n    window[NAMESPACE] = {\n      interceptorDisabled: false,\n      excludedUrls: [],\n      requests: [],\n    };\n\n    // Some browsers don't support FormData.entries(), so we polyfill that (sigh)\n    if (typeof FormData.prototype.entries == 'undefined') {\n      polyfillFormDataEntries();\n    }\n\n    if (supportsSessionStorage()) {\n      window.sessionStorage.removeItem(NAMESPACE);\n    }\n\n    if (typeof window.fetch == 'function') {\n      replaceFetch();\n      if (\n        typeof window.Promise === 'undefined' ||\n        typeof window.Promise.all !== 'function'\n      ) {\n        console.error(PKG_PREFIX + 'Fetch API preconditions not met!');\n      }\n    }\n\n    replaceXHR();\n\n    done(window[NAMESPACE]);\n\n    function replaceFetch() {\n      var _fetch = window.fetch;\n      window.fetch = function () {\n        // Default values if not overwritten\n        var request = {\n          method: 'GET',\n          requestHeaders: {},\n          requestBody: undefined,\n          url: '',\n        };\n        var input = arguments[0];\n        var init = arguments[1];\n        if (typeof input == 'string') {\n          request.url = input;\n        } else if (input instanceof URL) {\n          request.url = input.href;\n        } else {\n          if (input instanceof Request) {\n            // Request object\n            var clonedRequest = input.clone();\n            request.requestBody = clonedRequest.text();\n            request.url = clonedRequest.url;\n            request.requestHeaders = parseHeaders(clonedRequest.headers);\n            request.method = clonedRequest.method;\n          } else {\n            console.error(PKG_PREFIX + 'Unhandled input type to fetch API!');\n            request.requestBody = input.body;\n          }\n        }\n        if (init) {\n          if (typeof init.body !== 'undefined')\n            request.requestBody = parsePayload(init.body);\n          if (typeof init.method !== 'undefined') request.method = init.method;\n          request.requestHeaders = parseHeaders(init.headers);\n        }\n        addPendingRequest(request);\n\n        return _fetch.apply(window, arguments).then(function (response) {\n          // TODO: We could clone it multiple times and check for all type variations of body\n          var clonedResponse = response.clone();\n          var responsePromise = clonedResponse.text();\n\n          // After decoding the request's body (which may have come from Request#text())\n          // and the response body, we can store the completed request.\n          Promise.all([request.requestBody, responsePromise]).then(function (\n            results\n          ) {\n            completeFetchRequest(request, {\n              requestBody: results[0],\n              body: results[1],\n              statusCode: clonedResponse.status,\n              headers: parseHeaders(clonedResponse.headers),\n            });\n          });\n\n          // Forward the original response to the application on the current tick.\n          return response;\n        });\n      };\n    }\n\n    function replaceXHR() {\n      var originalOpen = XMLHttpRequest.prototype.open;\n      var originalSend = XMLHttpRequest.prototype.send;\n      var originalSetRequestHeader = XMLHttpRequest.prototype.setRequestHeader;\n      var originalAbort = XMLHttpRequest.prototype.abort;\n      var handleDoneRequest = function (xhr) {\n        if (xhr.readyState == XMLHttpRequest.prototype.DONE) {\n          var req = xhr.lastReq;\n          req.statusCode = xhr.status;\n          req.headers = xhr.getAllResponseHeaders();\n          // The body may need to be further processed, or may be ready synchronously.\n          var parsed = parseBody(xhr, req);\n          if (!parsed.deferred) {\n            completeXHRRequest(req, parsed.body);\n          }\n        }\n      };\n      XMLHttpRequest.prototype.open = function () {\n        this.lastMethod = arguments[0];\n        this.lastURL = arguments[1];\n        originalOpen.apply(this, arguments);\n      };\n      XMLHttpRequest.prototype.send = function () {\n        this.lastReq = {\n          method: this.lastMethod.toUpperCase(),\n          requestHeaders: this.lastRequestHeader || {},\n          requestBody: parsePayload(arguments[0]),\n          url: this.lastURL.toString(),\n        };\n        addPendingRequest(this.lastReq);\n        originalSend.apply(this, arguments);\n\n        var _this = this;\n        this.addEventListener('load', function () {\n          handleDoneRequest(_this);\n        });\n      };\n      XMLHttpRequest.prototype.setRequestHeader = function () {\n        if (!this.lastRequestHeader) {\n          this.lastRequestHeader = {};\n        }\n        this.lastRequestHeader[arguments[0]] = arguments[1];\n        originalSetRequestHeader.apply(this, arguments);\n      };\n      XMLHttpRequest.prototype.abort = function () {\n        handleDoneRequest(this);\n        originalAbort.apply(this, arguments);\n      };\n    }\n\n    function parseBody(xhr, request) {\n      if (xhr.responseType === 'arraybuffer') {\n        return {\n          body: new TextDecoder().decode(xhr.response),\n        };\n      } else if (xhr.responseType === 'blob') {\n        // Read the response like a file.\n        var fr = new FileReader();\n        fr.addEventListener('load', function () {\n          completeXHRRequest(request, new TextDecoder().decode(this.result));\n        });\n        fr.readAsArrayBuffer(xhr.response);\n        return { deferred: true };\n      }\n      // IE9 comp: need xhr.responseText\n      return {\n        body: xhr.response || xhr.responseText,\n      };\n    }\n\n    // Change every type of response header objects to raw text\n    function parseHeaders(headers) {\n      if (headers instanceof Headers) {\n        // IE compatibility can be ignored here, because\n        // the Headers object is only available in modern browsers.\n        // Also no new keywords are used, so IE won't panic upon parsing the script.\n        return Array.from(headers.entries())\n          .map(function (x) {\n            return x.join(': ');\n          })\n          .join('\\r\\n');\n      }\n      return headers || '';\n    }\n\n    /**\n     * Stringify the given XHR payload so it can be parsed as JSON\n     * @param {*} payload XHR request body that is sent to the remote server.\n     * @returns {string} JSON-parsable representation of the request body\n     */\n    function parsePayload(payload) {\n      if (typeof payload == 'string') {\n        return payload;\n      }\n      if (payload instanceof FormData) {\n        var parsed = {};\n        var entries = payload.entries();\n        var item;\n        while (((item = entries.next()), !item.done)) {\n          parsed[item.value[0]] = item.value.slice(1);\n        }\n        return JSON.stringify(parsed);\n      }\n      if (payload instanceof ArrayBuffer) {\n        return String.fromCharCode.apply(null, payload);\n      }\n      if (payload instanceof URLSearchParams) {\n        return payload.toString();\n      }\n\n      // Just try to convert it to a string, whatever it might be\n      try {\n        return JSON.stringify(payload);\n      } catch (e) {\n        console.error(PKG_PREFIX + 'Failed to stringify payload as JSON!', e);\n      }\n      return '';\n    }\n\n    function addPendingRequest(startedRequest) {\n      startedRequest.__processed = Date.now();\n      window[NAMESPACE].requests.push(startedRequest);\n      pushToSessionStorage(startedRequest);\n    }\n\n    function completeFetchRequest(startedRequest, completedRequest) {\n      // Merge the completed data with the started request.\n      startedRequest.requestBody = completedRequest.requestBody;\n      startedRequest.body = completedRequest.body;\n      startedRequest.headers = completedRequest.headers;\n      startedRequest.statusCode = completedRequest.statusCode;\n      startedRequest.__fulfilled = Date.now();\n      replaceInSessionStorage(startedRequest);\n    }\n\n    function completeXHRRequest(startedRequest, responseBody) {\n      // Merge the completed data with the started request.\n      startedRequest.body = responseBody;\n      startedRequest.__fulfilled = Date.now();\n      replaceInSessionStorage(startedRequest);\n    }\n\n    function getParsedSessionStorage() {\n      var rawData = window.sessionStorage.getItem(NAMESPACE);\n      if (!rawData) {\n        return [];\n      }\n      try {\n        return JSON.parse(rawData);\n      } catch (e) {\n        throw new Error(\n          PKG_PREFIX + 'Could not parse sessionStorage data: ' + e.message\n        );\n      }\n    }\n\n    function supportsSessionStorage() {\n      return (\n        typeof window.sessionStorage === 'object' &&\n        window.sessionStorage !== null &&\n        typeof window.sessionStorage.setItem === 'function' &&\n        typeof window.sessionStorage.removeItem === 'function'\n      );\n    }\n\n    function shouldExcludeRequestByUrl(url) {\n      return window[NAMESPACE].excludedUrls.some(function (regex) {\n        return regex.test(url);\n      });\n    }\n\n    function pushToSessionStorage(req) {\n      if (window[NAMESPACE].interceptorDisabled == true) {\n        return;\n      }\n      if (!supportsSessionStorage()) {\n        return;\n      }\n      if (shouldExcludeRequestByUrl(req.url)) {\n        return;\n      }\n      var parsed = getParsedSessionStorage();\n      parsed.push(req);\n      window.sessionStorage.setItem(NAMESPACE, JSON.stringify(parsed));\n    }\n\n    function replaceInSessionStorage(completedRequest) {\n      if (window[NAMESPACE].interceptorDisabled == true) {\n        return;\n      }\n      if (!supportsSessionStorage()) {\n        return;\n      }\n      var parsed = getParsedSessionStorage();\n      // Unlike requests held in the namespace, no session-stored requests can share object equality\n      // with the completed request, due to the string serialization. Instead, we must look for an\n      // item with the same \"__processed\" time. In case multiple requests are added simultaneously,\n      // the url and method are used to further disambiguate the serialized requests.\n      for (\n        var storedRqNumber = 0;\n        storedRqNumber < parsed.length;\n        ++storedRqNumber\n      ) {\n        var r = parsed[storedRqNumber];\n        if (\n          r.__processed === completedRequest.__processed &&\n          r.url === completedRequest.url &&\n          r.method === completedRequest.method\n        ) {\n          parsed[storedRqNumber] = completedRequest;\n          break;\n        }\n      }\n      window.sessionStorage.setItem(NAMESPACE, JSON.stringify(parsed));\n    }\n\n    function polyfillFormDataEntries() {\n      var originalAppend = FormData.prototype.append;\n      FormData.prototype.append = function () {\n        this.__entries = this.__entries || [];\n        this.__entries.push(Array.prototype.slice.call(arguments));\n        originalAppend.apply(this, arguments);\n      };\n      FormData.prototype.entries = function () {\n        return this.__entries;\n      };\n    }\n  }).apply(null, arguments)",
  "args": []
}